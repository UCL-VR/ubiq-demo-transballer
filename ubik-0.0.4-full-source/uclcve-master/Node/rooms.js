const { Message } = require('./messaging');

class SerialisedDictionary{
    static From(dictionary){
        return Object.assign(...dictionary.keys.map((k,i) => ({[k]: dictionary.values[i]})));
    }

    static To(object){
        return { keys: Object.keys(object), values: Object.values(object) };
    }
}

// This is the primary server for rendezvous and bootstrapping. It accepts websocket connections,
// (immediately handing them over to RoomPeer instances) and performs book-keeping for finding
// and joining rooms.
class RoomServer{
    constructor(){
        this.rooms = {};
        this.version = "0.0.3";
    }

    addServer(server){
        console.log("Added RoomServer port " + server.port);
        server.onConnection.push(this.onConnection.bind(this));
    }

    onConnection(wrapped){
        console.log("RoomServer: Client Connection from " + wrapped.endpoint().address + ":" + wrapped.endpoint().port);
        new RoomPeer(this, wrapped);
    }

    async join(peer, args){

        var guid = args.guid;

        // check if we should be creating a new room
        if(guid == ""){
            var index = 0;
            while(true){
                guid = "Room " + index++;
                if(!this.rooms.hasOwnProperty(guid)){
                    break;
                }
            }
        }

        // find the room
        if(!this.rooms.hasOwnProperty(guid)){
            var room = new Room(server, guid); // create a dynamic room if one does not exist
            room.password = args.password;
            this.rooms[guid] = room;
        }

        // do checks here...
        // ...

        var room = this.rooms[guid];
        
        room.addPeer(peer);

        console.log(peer.guid + " joined room " + room.guid);
    }

    getRooms(){
        return {
            rooms: Object.values(this.rooms).map(r => r.getRoomArgs()),
            version: this.version
        }
    }

    removeRoom(room){
        delete this.rooms[room.guid];
        console.log("RoomServer: Deleting empty room " + room.guid);
    }

    setBlob(args){
        if(this.rooms.hasOwnProperty(args.room)){ // only existing rooms may have blobs set
            this.rooms[args.room].blobs[args.guid] = args.blob;
        }
    }

    getBlob(args){
        if(this.rooms.hasOwnProperty(args.room)){ // only existing rooms may have blobs set
            if(this.rooms[args.room].blobs.hasOwnProperty(args.guid)){
                args.blob = this.rooms[args.room].blobs[args.guid];
            }
        }
    }
}

// When peers are not in a room, their room member is set to an instance of EmptyRoom, which contains
// callbacks and basic information to signal that they are not members of any room.
class EmptyRoom{
    constructor(){
        this.guid = null;
    }

    removePeer(peer){
    }

    updatePeer(peer){
    }

    processMessage(peer, message){
    }

    getPeersArgs(){
    }

    updateRoom(roomargs){
        this.roomargs = roomargs;
    }

    getRoomArgs(){
        return {
            guid: "",
            name: "",
            peers: [],
            properties: [],
        }
    }
}

// The RoomPeer class manages a WebSocketConnection to a RoomClient. This class
// interacts with the connection, formatting and parsing messages and calling the 
// appropriate methods on RoomServer and others.
class RoomPeer{
    constructor(server, connection){
        this.server = server;
        this.connection = connection;
        this.room = new EmptyRoom();
        this.objectid = 0;
        this.componentid = 0;
        this.guid = "";
        this.properties = [];
        this.connection.onMessage.push(this.onMessage.bind(this));
        this.connection.onClose.push(this.onClose.bind(this));
    }

    onMessage(message){
        if(message.objectid == 1 && message.componentid == 1){
            message.object = message.toObject();
            message.type = message.object.type;
            message.args = JSON.parse(message.object.args);
            switch(message.type){
                case "Join":
                    // a join message always includes an update about the peer properties
                    this.setPeerArgs(message.args.peer);
                    if(this.room.guid != null){
                        this.room.removePeer(this);
                    }
                    this.server.join(this, message.args);
                break;
                case "UpdatePeer":
                    this.setPeerArgs(message.args);
                    this.room.updatePeer(this);
                    break;
                case "UpdateRoom":
                    this.room.updateRoom(message.args);
                    break;
                case "RequestRooms":
                    this.sendRooms(this.server.getRooms());
                    break;
                case "SetBlob":
                    this.server.setBlob(message.args);
                    break;
                case "GetBlob":
                    this.server.getBlob(message.args);
                    this.sendBlob(message.args);
                    break;
            };
        }else{
            this.room.processMessage(this, message);
        }
    }

    setPeerArgs(peer){
        this.objectid = peer.networkObject;
        this.componentid = peer.component;
        this.properties = peer.properties;
        this.guid = peer.guid;
    }

    getPeerArgs(){
        return { 
            guid: this.guid,
            networkObject: this.objectid,
            component : this.componentid,
            properties: this.properties
        }
    }

    onClose(){
        this.room.removePeer(this);
    }

    setRoom(room){
        this.room = room;
        this.sendAccepted();
    }

    sendAccepted(){
        this.send(
            Message.Create(
                this.objectid, 
                this.componentid,
                { 
                    type: "Accepted",
                    args: JSON.stringify({
                        room: this.room.getRoomArgs(), 
                        peers: this.room.getPeersArgs()
                    })
                }
            )
        );
    }

    sendRoom(){
        this.send(
            Message.Create(
                this.objectid, 
                this.componentid,
                { 
                    type: "UpdateRoom",
                    args: JSON.stringify(this.room.getRoomArgs()) 
                }
            )
        );
    }

    sendRooms(rooms){
        this.send(
            Message.Create(
                this.objectid,
                this.componentid,
                {
                    type: "Rooms",
                    args: JSON.stringify(rooms)
                }
            )
        )
    }

    sendPeer(peer){
        this.send(
            Message.Create(
                this.objectid,
                this.componentid,
                {
                    type: "UpdatePeer",
                    args: JSON.stringify(peer.getPeerArgs())
                }
            )
        )
    }

    sendPeerRemoved(peer){
        this.send(
            Message.Create(
                this.objectid,
                this.componentid,
                {
                    type: "RemovedPeer",
                    args: JSON.stringify(peer.getPeerArgs())
                }
            )
        )
    }

    sendBlob(blobArgs){
        this.send(
            Message.Create(
                this.objectid,
                this.componentid,
                {
                    type: "Blob",
                    args: JSON.stringify(blobArgs)
                }
            )
        )
    }

    send(message){
        this.connection.send(message);
    }
}

class Room{
    constructor(server, guid){
        this.server = server;
        this.guid = guid;
        this.name = guid
        this.peers = [];
        this.properties = {};
        this.blobs = {};
    }

    addPeer(peer){
        this.peers.push(peer);
        peer.setRoom(this);
        this.updatePeer(peer);
    }

    updatePeer(peer){ // The peer arguments are only stored in one place (RoomPeer), so from the rooms point of view, updating the peer is just sending a message
        this.peers.forEach(otherpeer => {
            otherpeer.sendPeer(peer);
        });
    }

    removePeer(peer){
        const index = this.peers.indexOf(peer);
        if (index > -1) {
          this.peers.splice(index, 1);
        }
        peer.setRoom(new EmptyRoom()); // signal that the leave is complete
        this.peers.forEach(otherpeer => {
            otherpeer.sendPeerRemoved(peer); // (no check here because peer was already removed from the list)
        });

        console.log(peer.guid + " left room " + this.name);

        if(this.peers.length <= 0){
            this.server.removeRoom(this);
        }
    }

    getRoomArgs(){
        return { 
            guid: this.guid,
            name: this.name,
            properties : SerialisedDictionary.To(this.properties)
        };
    }

    updateRoom(args){
        if(args.guid != this.guid){
            console.log("Attempt to update room outside membership.");
        }
        this.name = args.name;
        Object.assign(this.properties, SerialisedDictionary.From(args.properties));  // This line converts the key/value properties array into a JS object, and merges it with the existing properties.
        this.peers.forEach(peer =>{
            peer.sendRoom();
        });
    }

    getPeersArgs(){
        return this.peers.map(c => c.getPeerArgs());
    }

    processMessage(source, message){
        this.peers.forEach(peer =>{
            if(peer != source){
                peer.send(message);
            }
        })
    }
}

module.exports = {
    RoomServer
}